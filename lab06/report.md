# Распределенные эволюционные алгоритмы

## Цель работы

Целью данной работы является освоение принципов построения
распределенных и параллельных эволюционных алгоритмов для
повышения их производительности и эффективности.

## Реализация

В качестве операторов генетического алгоритма были взяты
результаты лабораторной работы 2.

1. Генерация кандидатов была реализована как сэмплирование из
равномерного распределения.

2. Оператор мутации реализован как наложение нормального шума
на n случайных координат элемента популяции. Координаты
выбирались независимо. Лучший результат в экспериментах показал
оператор с фиксированным значением n = 1.

3. В качестве оператора кроссовера был использован
`Direction-Based Exponential Crossover Operator` из статьи
[Amit Kumar Das & Dilip Kumar Pratihar](https://www.researchgate.net/publication/340404625_A_Direction-Based_Exponential_Crossover_Operator_for_Real-Coded_Genetic_Algorithm). Данный оператор опирается на
предполагаемое напревление к оптимуму функции и показывает себя
лучше, чем стандартные операторы (линейные комбинации предков,
комбинаторные комбинации координат). Данный оператор использует
параметр a. В ходе экспериментов мы установили значение
a = 3.4.

MasterSlaveAlg взят без изменений.

IslandsAlg использует симметричные модели эволюции на
5 островах. Из-за этого размер популяции каждого острова равен
20. Размер эпохи выставлен в 50, поэтому количество эпох в
50 раз меньше показателя `generations` для других алгоритмов
(1000). В качестве стратегии миграции используется RingMigration.

## Результаты экспериментов

<table>
    <thead>
        <tr>
            <th rowspan=2>Complexity</th>
            <th rowspan=2>Metric</th>
            <th colspan=3 style="text-align: center;">Algorithm</th>
        </tr>
        <tr>
            <th>Single</th>
            <th>Multi</th>
            <th>Islands</th>
        </tr>
    </thead>
    <tbody>
<tr>
	<td rowspan=2>1</td>
	<td>Time</td>
	<td> 274,12 </td>
	<td> 297,38 </td>
	<td> 88,06 </td>
</tr>
<tr>
	<td>Result</td>
	<td> 7,7 </td>
	<td> 7,68 </td>
	<td> 7,81 </td>
</tr><tr>
	<td rowspan=2>2</td>
	<td>Time</td>
	<td> 356,75 </td>
	<td> 320,88 </td>
	<td> 86,62 </td>
</tr>
<tr>
	<td>Result</td>
	<td> 7,69 </td>
	<td> 7,71 </td>
	<td> 7,82 </td>
</tr><tr>
	<td rowspan=2>3</td>
	<td>Time</td>
	<td> 438,5 </td>
	<td> 348,12 </td>
	<td> 116,81 </td>
</tr>
<tr>
	<td>Result</td>
	<td> 7,71 </td>
	<td> 7,66 </td>
	<td> 7,8 </td>
</tr><tr>
	<td rowspan=2>4</td>
	<td>Time</td>
	<td> 553,81 </td>
	<td> 425,25 </td>
	<td> 151,44 </td>
</tr>
<tr>
	<td>Result</td>
	<td> 7,7 </td>
	<td> 7,75 </td>
	<td> 7,8 </td>
</tr><tr>
	<td rowspan=2>5</td>
	<td>Time</td>
	<td> 635,12 </td>
	<td> 441 </td>
	<td> 170,81 </td>
</tr>
<tr>
	<td>Result</td>
	<td> 7,69 </td>
	<td> 7,73 </td>
	<td> 7,8 </td>
</tr><tr>
	<td rowspan=2>6</td>
	<td>Time</td>
	<td> 703,31 </td>
	<td> 458,81 </td>
	<td> 195,62 </td>
</tr>
<tr>
	<td>Result</td>
	<td> 7,73 </td>
	<td> 7,68 </td>
	<td> 7,82 </td>
</tr><tr>
	<td rowspan=2>7</td>
	<td>Time</td>
	<td> 776 </td>
	<td> 475,94 </td>
	<td> 221,19 </td>
</tr>
<tr>
	<td>Result</td>
	<td> 7,72 </td>
	<td> 7,7 </td>
	<td> 7,83 </td>
</tr>
    </tbody>
</table>

![effectiveness](./plot.png)

## Вопросы

1. Островной алгоритм показывает более высокое качество
и большее быстродействие, однако назвать его однозначно
лучшим нельзя, т.к. его параметры не сопоставляются с
параметрами MasterSlave 1 к 1. (Надо бы количество вычислений
fitness проверить)
2. Влияние увеличения размерности проблемы на MasterSlave
будет схожим с влиянием на однопоточный алгоритм, хотя и
кратно меньшим. На островную модель влияние будет более
сильным.
3. Оба алгоритма замедлят свою работу из-за более частого
вычисления fitness в поколении, однако вероятно вырастет
качество найденного решения.
4. Мы ограничены лишь вычислительными ресурсами, позволяющими
нам производить конечное количество процессов эволюции
одновременно. Еще стоит учесть, что процесс миграции является
барьером синхронизации для всех островов. И вообще, это все
становится похоже на мета-эволюционный алгоритм, в котором
остров является представителем решения, стандартные
эволюционные операторы - мутации нашего представителя, а
миграция - кроссовер.
